!function e(n,t,a){function r(i,s){if(!t[i]){if(!n[i]){var c="function"==typeof require&&require;if(!s&&c)return c(i,!0);if(o)return o(i,!0);var l=new Error("Cannot find module '"+i+"'");throw l.code="MODULE_NOT_FOUND",l}var v=t[i]={exports:{}};n[i][0].call(v.exports,function(e){var t=n[i][1][e];return r(t||e)},v,v.exports,e,n,t,a)}return t[i].exports}for(var o="function"==typeof require&&require,i=0;i<a.length;i++)r(a[i]);return r}({1:[function(e,n,t){"use strict";THREE.OBJLoader=function(e){this.manager=void 0!==e?e:THREE.DefaultLoadingManager,this.materials=null,this.regexp={vertex_pattern:/^v\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,normal_pattern:/^vn\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,uv_pattern:/^vt\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,face_vertex:/^f\s+(-?\d+)\s+(-?\d+)\s+(-?\d+)(?:\s+(-?\d+))?/,face_vertex_uv:/^f\s+(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)(?:\s+(-?\d+)\/(-?\d+))?/,face_vertex_uv_normal:/^f\s+(-?\d+)\/(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\/(-?\d+)(?:\s+(-?\d+)\/(-?\d+)\/(-?\d+))?/,face_vertex_normal:/^f\s+(-?\d+)\/\/(-?\d+)\s+(-?\d+)\/\/(-?\d+)\s+(-?\d+)\/\/(-?\d+)(?:\s+(-?\d+)\/\/(-?\d+))?/,object_pattern:/^[og]\s*(.+)?/,smoothing_pattern:/^s\s+(\d+|on|off)/,material_library_pattern:/^mtllib /,material_use_pattern:/^usemtl /}},THREE.OBJLoader.prototype={constructor:THREE.OBJLoader,load:function(e,n,t,a){var r=this,o=new THREE.FileLoader(r.manager);o.setPath(this.path),o.load(e,function(e){n(r.parse(e))},t,a)},setPath:function(e){this.path=e},setMaterials:function(e){this.materials=e},_createParserState:function(){var e={objects:[],object:{},vertices:[],normals:[],uvs:[],materialLibraries:[],startObject:function(e,n){if(this.object&&!1===this.object.fromDeclaration)return this.object.name=e,void(this.object.fromDeclaration=!1!==n);var t=this.object&&"function"==typeof this.object.currentMaterial?this.object.currentMaterial():void 0;if(this.object&&"function"==typeof this.object._finalize&&this.object._finalize(!0),this.object={name:e||"",fromDeclaration:!1!==n,geometry:{vertices:[],normals:[],uvs:[]},materials:[],smooth:!0,startMaterial:function(e,n){var t=this._finalize(!1);t&&(t.inherited||t.groupCount<=0)&&this.materials.splice(t.index,1);var a={index:this.materials.length,name:e||"",mtllib:Array.isArray(n)&&n.length>0?n[n.length-1]:"",smooth:void 0!==t?t.smooth:this.smooth,groupStart:void 0!==t?t.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(e){var n={index:"number"==typeof e?e:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return n.clone=this.clone.bind(n),n}};return this.materials.push(a),a},currentMaterial:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]},_finalize:function(e){var n=this.currentMaterial();if(n&&-1===n.groupEnd&&(n.groupEnd=this.geometry.vertices.length/3,n.groupCount=n.groupEnd-n.groupStart,n.inherited=!1),e&&this.materials.length>1)for(var t=this.materials.length-1;t>=0;t--)this.materials[t].groupCount<=0&&this.materials.splice(t,1);return e&&0===this.materials.length&&this.materials.push({name:"",smooth:this.smooth}),n}},t&&t.name&&"function"==typeof t.clone){var a=t.clone(0);a.inherited=!0,this.object.materials.push(a)}this.objects.push(this.object)},finalize:function(){this.object&&"function"==typeof this.object._finalize&&this.object._finalize(!0)},parseVertexIndex:function(e,n){var t=parseInt(e,10);return 3*(t>=0?t-1:t+n/3)},parseNormalIndex:function(e,n){var t=parseInt(e,10);return 3*(t>=0?t-1:t+n/3)},parseUVIndex:function(e,n){var t=parseInt(e,10);return 2*(t>=0?t-1:t+n/2)},addVertex:function(e,n,t){var a=this.vertices,r=this.object.geometry.vertices;r.push(a[e+0]),r.push(a[e+1]),r.push(a[e+2]),r.push(a[n+0]),r.push(a[n+1]),r.push(a[n+2]),r.push(a[t+0]),r.push(a[t+1]),r.push(a[t+2])},addVertexLine:function(e){var n=this.vertices,t=this.object.geometry.vertices;t.push(n[e+0]),t.push(n[e+1]),t.push(n[e+2])},addNormal:function(e,n,t){var a=this.normals,r=this.object.geometry.normals;r.push(a[e+0]),r.push(a[e+1]),r.push(a[e+2]),r.push(a[n+0]),r.push(a[n+1]),r.push(a[n+2]),r.push(a[t+0]),r.push(a[t+1]),r.push(a[t+2])},addUV:function(e,n,t){var a=this.uvs,r=this.object.geometry.uvs;r.push(a[e+0]),r.push(a[e+1]),r.push(a[n+0]),r.push(a[n+1]),r.push(a[t+0]),r.push(a[t+1])},addUVLine:function(e){var n=this.uvs,t=this.object.geometry.uvs;t.push(n[e+0]),t.push(n[e+1])},addFace:function(e,n,t,a,r,o,i,s,c,l,v,u){var m,d=this.vertices.length,h=this.parseVertexIndex(e,d),f=this.parseVertexIndex(n,d),g=this.parseVertexIndex(t,d);if(void 0===a?this.addVertex(h,f,g):(m=this.parseVertexIndex(a,d),this.addVertex(h,f,m),this.addVertex(f,g,m)),void 0!==r){var p=this.uvs.length;h=this.parseUVIndex(r,p),f=this.parseUVIndex(o,p),g=this.parseUVIndex(i,p),void 0===a?this.addUV(h,f,g):(m=this.parseUVIndex(s,p),this.addUV(h,f,m),this.addUV(f,g,m))}if(void 0!==c){var b=this.normals.length;h=this.parseNormalIndex(c,b),f=c===l?h:this.parseNormalIndex(l,b),g=c===v?h:this.parseNormalIndex(v,b),void 0===a?this.addNormal(h,f,g):(m=this.parseNormalIndex(u,b),this.addNormal(h,f,m),this.addNormal(f,g,m))}},addLineGeometry:function(e,n){this.object.geometry.type="Line";for(var t=this.vertices.length,a=this.uvs.length,r=0,o=e.length;r<o;r++)this.addVertexLine(this.parseVertexIndex(e[r],t));for(var i=0,o=n.length;i<o;i++)this.addUVLine(this.parseUVIndex(n[i],a))}};return e.startObject("",!1),e},parse:function(e){console.time("OBJLoader");var n=this._createParserState();-1!==e.indexOf("\r\n")&&(e=e.replace(/\r\n/g,"\n")),-1!==e.indexOf("\\\n")&&(e=e.replace(/\\\n/g,""));for(var t=e.split("\n"),a="",r="",o="",i=[],s="function"==typeof"".trimLeft,c=0,l=t.length;c<l;c++)if(a=t[c],a=s?a.trimLeft():a.trim(),0!==a.length&&"#"!==(r=a.charAt(0)))if("v"===r)if(" "===(o=a.charAt(1))&&null!==(i=this.regexp.vertex_pattern.exec(a)))n.vertices.push(parseFloat(i[1]),parseFloat(i[2]),parseFloat(i[3]));else if("n"===o&&null!==(i=this.regexp.normal_pattern.exec(a)))n.normals.push(parseFloat(i[1]),parseFloat(i[2]),parseFloat(i[3]));else{if("t"!==o||null===(i=this.regexp.uv_pattern.exec(a)))throw new Error("Unexpected vertex/normal/uv line: '"+a+"'");n.uvs.push(parseFloat(i[1]),parseFloat(i[2]))}else if("f"===r)if(null!==(i=this.regexp.face_vertex_uv_normal.exec(a)))n.addFace(i[1],i[4],i[7],i[10],i[2],i[5],i[8],i[11],i[3],i[6],i[9],i[12]);else if(null!==(i=this.regexp.face_vertex_uv.exec(a)))n.addFace(i[1],i[3],i[5],i[7],i[2],i[4],i[6],i[8]);else if(null!==(i=this.regexp.face_vertex_normal.exec(a)))n.addFace(i[1],i[3],i[5],i[7],void 0,void 0,void 0,void 0,i[2],i[4],i[6],i[8]);else{if(null===(i=this.regexp.face_vertex.exec(a)))throw new Error("Unexpected face line: '"+a+"'");n.addFace(i[1],i[2],i[3],i[4])}else if("l"===r){var v=a.substring(1).trim().split(" "),u=[],m=[];if(-1===a.indexOf("/"))u=v;else for(var d=0,h=v.length;d<h;d++){var f=v[d].split("/");""!==f[0]&&u.push(f[0]),""!==f[1]&&m.push(f[1])}n.addLineGeometry(u,m)}else if(null!==(i=this.regexp.object_pattern.exec(a))){var g=(" "+i[0].substr(1).trim()).substr(1);n.startObject(g)}else if(this.regexp.material_use_pattern.test(a))n.object.startMaterial(a.substring(7).trim(),n.materialLibraries);else if(this.regexp.material_library_pattern.test(a))n.materialLibraries.push(a.substring(7).trim());else{if(null===(i=this.regexp.smoothing_pattern.exec(a))){if("\0"===a)continue;throw new Error("Unexpected line: '"+a+"'")}var p=i[1].trim().toLowerCase();n.object.smooth="1"===p||"on"===p;var b=n.object.currentMaterial();b&&(b.smooth=n.object.smooth)}n.finalize();var x=new THREE.Group;x.materialLibraries=[].concat(n.materialLibraries);for(var c=0,l=n.objects.length;c<l;c++){var E=n.objects[c],y=E.geometry,R=E.materials,T="Line"===y.type;if(0!==y.vertices.length){var P=new THREE.BufferGeometry;P.addAttribute("position",new THREE.BufferAttribute(new Float32Array(y.vertices),3)),y.normals.length>0?P.addAttribute("normal",new THREE.BufferAttribute(new Float32Array(y.normals),3)):P.computeVertexNormals(),y.uvs.length>0&&P.addAttribute("uv",new THREE.BufferAttribute(new Float32Array(y.uvs),2));for(var w=[],C=0,_=R.length;C<_;C++){var z=R[C],b=void 0;if(null!==this.materials&&(b=this.materials.create(z.name),T&&b&&!(b instanceof THREE.LineBasicMaterial))){var S=new THREE.LineBasicMaterial;S.copy(b),b=S}b||(b=T?new THREE.LineBasicMaterial:new THREE.MeshPhongMaterial,b.name=z.name),b.shading=z.smooth?THREE.SmoothShading:THREE.FlatShading,w.push(b)}var H;if(w.length>1){for(var C=0,_=R.length;C<_;C++){var z=R[C];P.addGroup(z.groupStart,z.groupCount,C)}var D=new THREE.MultiMaterial(w);H=T?new THREE.LineSegments(P,D):new THREE.Mesh(P,D)}else H=T?new THREE.LineSegments(P,w[0]):new THREE.Mesh(P,w[0]);H.name=E.name,x.add(H)}}return console.timeEnd("OBJLoader"),x}}},{}],2:[function(e,n,t){"use strict";var a=e("glslify"),r=a(['//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_0(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_0(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_0(vec4 x)\n{\n  return mod289_0(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_0(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade_0(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise_0(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289_0(Pi0);\n  Pi1 = mod289_0(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute_0(permute_0(ix) + iy);\n  vec4 ixy0 = permute_0(ixy + iz0);\n  vec4 ixy1 = permute_0(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt_0(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt_0(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade_0(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\n//\n// GLSL textureless classic 2D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289_1(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_1(vec4 x)\n{\n  return mod289_1(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_1(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec2 fade_1(vec2 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise_1(vec2 P)\n{\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod289_1(Pi); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute_1(permute_1(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n  vec4 gy = abs(gx) - 0.5 ;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n\n  vec4 norm = taylorInvSqrt_1(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade_1(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform float opacity;\nuniform sampler2D tDiffuse;\nuniform sampler2D tDiffusePrev;\nuniform sampler2D tex1;\nuniform sampler2D tex2;\n\nuniform float mouseX;\nuniform float mouseY;\nuniform float time;\nuniform float v;\n\nvarying vec2 vUv;\nvarying vec3 vPos;\n\nfloat rand(vec2 n) {\n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\n// vec4 swirl(sampler2D tex, vec2 uv)\n// {\n\n//     float radius = 0.2;\n\n//     vec4 tex2 = texture2D(tex, uv);\n\n//     float angle = tex2.x * 0.01;\n\n//     vec2 center = vec2(mouseX, mouseY);\n//     vec2 tc = (uv * 1.0) - center;\n//     float dist = length(tc);\n// //    if( dist < radius )\n// //    {\n//         float percent = (radius - dist) / radius;\n//         float theta = percent * percent * angle * 8.0;\n//         float s = sin(theta);\n//         float c = cos(theta);\n//         tc = vec2(dot(tc, vec2(c, -s)), dot(tc, vec2(s, c)));\n// //    }\n//     tc += center;\n//     return texture2D(tex, tc / 1.0);\n// }\n\nvoid main() {\n\n//    vec2 tc = (vUv * 1.0) - vec2(mouseX, mouseY);\n//    float dist = length(tc);\n\n//    if( dist < 0.3 )\n//    {\n//      gl_FragColor = vec4(1.,0.0,0.0,1.0);\n//    }else{\n//      gl_FragColor = vec4(0.,1.0,0.0,1.0);\n//    }\n//  vec4 texel2 = swirl( tDiffuse, vUv );\n\n  // vec2 vUv2 = vUv;\n  // vUv2.x *= 0.09718136091;\n  // vUv2.x *= 2.;\n  // vec4 texel3 = texture2D( tDiffusePrev, vUv);\n  \n  \n  // vec4 texel3 = texture2D( textTex, vUv * 2.4 + vec2(-0.7,-0.7) ) ;\n  // vec2 dd = vec2(1.0-texel3.xy) * -cnoise2(vec2(vUv)) * 0.01;\n  vec2 dd = vec2(0.0,0.0);\n  float v = 0.004;\n  // vec4 texel1 = texture2D( tDiffuse, vUv );\n  vec2 vUv2 = vUv * 1.03;\n  vec4 sum = vec4( 0.0 );\n  sum += texture2D( tDiffuse, vec2( vUv2.x, vUv2.y - 4.0 * v ) ) * 0.051/2.;\n  sum += texture2D( tDiffuse, vec2( vUv2.x, vUv2.y - 3.0 * v ) ) * 0.0918/2.;\n  sum += texture2D( tDiffuse, vec2( vUv2.x, vUv2.y - 2.0 * v ) ) * 0.12245/2.;\n  sum += texture2D( tDiffuse, vec2( vUv2.x, vUv2.y - 1.0 * v ) ) * 0.1531/2.;\n  sum += texture2D( tDiffuse, vec2( vUv2.x, vUv2.y ) ) * 0.1633/2.;\n  sum += texture2D( tDiffuse, vec2( vUv2.x, vUv2.y + 1.0 * v ) ) * 0.1531/2.;\n  sum += texture2D( tDiffuse, vec2( vUv2.x, vUv2.y + 2.0 * v ) ) * 0.12245/2.;\n  sum += texture2D( tDiffuse, vec2( vUv2.x, vUv2.y + 3.0 * v ) ) * 0.0918/2.;\n  sum += texture2D( tDiffuse, vec2( vUv2.x, vUv2.y + 4.0 * v ) ) * 0.051/2.;\n\n  sum += texture2D( tDiffuse, vec2( vUv2.x - 4.0 * v, vUv2.y ) ) * 0.051/2.;\n  sum += texture2D( tDiffuse, vec2( vUv2.x - 3.0 * v, vUv2.y ) ) * 0.0918/2.;\n  sum += texture2D( tDiffuse, vec2( vUv2.x - 2.0 * v, vUv2.y ) ) * 0.12245/2.;\n  sum += texture2D( tDiffuse, vec2( vUv2.x - 1.0 * v, vUv2.y ) ) * 0.1531/2.;\n  sum += texture2D( tDiffuse, vec2( vUv2.x, vUv2.y ) ) * 0.1633/2.;\n  sum += texture2D( tDiffuse, vec2( vUv2.x + 1.0 * v , vUv2.y) ) * 0.1531/2.;\n  sum += texture2D( tDiffuse, vec2( vUv2.x + 2.0 * v , vUv2.y) ) * 0.12245/2.;\n  sum += texture2D( tDiffuse, vec2( vUv2.x + 3.0 * v , vUv2.y) ) * 0.0918/2.;\n  sum += texture2D( tDiffuse, vec2( vUv2.x + 4.0 * v , vUv2.y) ) * 0.051/2.;\n  \n  vec4 texelC = texture2D( tDiffuse, (vUv) - vec2(0.002,0.002) ) ;    \n  vec4 texelA = texture2D( tDiffuse, (vUv + cnoise_1(vec2(vUv)* 40.0)* 0.002)) ;\n  vec4 texelA1 = texture2D( tDiffuse, (vUv + cnoise_1(vec2(vUv)* 40.0)* 0.004) * vec2(1.03,1.03) + vec2(0.004,0.002)  ) ;\n  // vec4 texel3 = texture2D( tDiffuse, vUv + cnoise2(vec2(vUv)*-2.2)* 0.005 ) ;\n  // vec4 texel2 = texture2D( tDiffuse, vec2(vUv.y, vUv.x) + dd) ;\n  // vec4 texel4 = texture2D( tDiffuse, vUv * vec2(mix(0.0,1.0,cnoise2(vec2(vUv.x*3.0,vUv.y*3.0))) )) ;\n  // vec4 texel2 = texture2D( tDiffuse, vec2(1.0-vUv.x,1.0-vUv.y) + vec2(0.0,0.3) ) ;\n  // vec4 texel3 = texture2D( tDiffuse, vec2(vUv.x,vUv.y) + vec2(0.0,-0.3) ) ;\n  // vec4 texel3 = texture2D( tDiffuse, vec2(vUv.x,vUv.y) + vec2(0.1,0.0) ) ;\n\n//  vec4 texel = texture2D( tDiffuse, vUv + vec2(mouseX,mouseY) * cnoise2(vec2(vUv) * 2.0) );\n\n  // "vec4 texel2 = texture2D( tDiffusePrev, vUv );",\n\n//  vec2 vUv2 = vUv;\n//  float dist = distance(vec2((mouseX*-1. + 5.0)/10.0,(mouseY + 5.0)/10.0), vUv);\n//  dist /= v * 10.0;\n//  vUv2 -= vec2(mouseX,mouseY);\n//  if (dist < 0.5){\n//     float percent = 1.0 + ((0.5 - dist) / 0.5) * 1.0;\n//     vUv2 = vUv2 * percent;\n//  }\n//  vUv2 += vec2(mouseX,mouseY);\n//  vec4 texel = texture2D( tDiffuse, vUv2);\n\n//   gl_FragColor = opacity * (texel*0.5 + texel2*0.5);\n//   gl_FragColor = (texel2*0.5 + texel3*0.5);\n  // "gl_FragColor = texel + texel2*0.5;",\n  // "gl_FragColor = texel + vec4(0.0,0.0,0.0,1.0);",\n//   gl_FragColor = vec4(sin(time)+1.,0.0,0.0,1.0);\n//   gl_FragColor = vec4(texel2.x, 0.0,0.0,1.0);\n//  gl_FragColor = vec4(texel2.xyz,0.1);\n//  gl_FragColor = texel2;\n\n  // gl_FragColor += texel1 + vec4(vec3(rand(vUv*time)),1.0)*0.08;\n  // gl_FragColor += texel2;\n  // gl_FrnpmagColor += texel2;\n  // gl_FragColor += texel4;\n\n  // gl_FragColor = texel1;\n  // float dd = 2.0;\n  // gl_FragColor = vec4(\n  //   vec3(\n  //     cnoise3(vPos*dd+time)*0.5 + 0.5 ,\n  //     cnoise3(vPos*dd+time)*0.5 + 0.5 , \n  //     0.5\n  //     ),//cnoise3(vPos*dd+time)*0.5 + 0.5 ),\n  //   1.0\n  // );\n  \n  // gl_FragColor = vec4(vec3(cnoise3(vPos*10.0+time)),1.0);\n  // gl_FragColor = vec4(vec3(cnoise2(vec2(vUv.x*20.0, vUv.y*20.0))),1.0);\n  // gl_FragColor = vec4(vec3(smoothstep(0.0,0.5,vec3(dist))),1.0);\n  //gl_FragColor = vec4(0.5,0.5,0.5 + smoothstep(0.0,0.5,dist),1.0);\n  // gl_FragColor += vec4(0.0,0.0,smoothstep(0.0,1.0,dist*5.0)*.5 ,1.0);\n  // gl_FragColor = vec4( vec3(smoothstep(0.0,1.0,dist*4.0)*.5) ,1.0 );\n  // gl_FragColor = vec4(texel1 + texel2);\n  // gl_FragColor = vec4(texel4);\n\n  sum += vec4(vec3(\n    rand(vUv * 2.2 + time)*1.7\n  ),1.0);\n\n  sum = vec4(\n    normalize(vec3( sum.x * step(0.7,sum.x))),\n    1.0\n  );\n  \n  sum = vec4(\n    vec3( sum.xyz - texelA1.xyz) * 0.4,\n    1.0\n  );\n  \n  vec4 texelB = vec4(\n    vec3(1.0 -  max(0.0,sum.x)),\n    1.0\n  );\n\n  gl_FragColor = vec4(0.3,0.3,0.38,1.0);\n\n  vec4 nom = texture2D( tex2, vUv - 0.007);\n  gl_FragColor += nom;\n\n  // gl_FragColor = vec4(0.0,0.2,0.2,1.0);\n  gl_FragColor -= nom * texelA * texelB;// * vec4(vec3(230./255., 185.4/255., 168./255.),1.0);\n\n  // gl_FragColor += vec4(vec3(-1.*texelC.xyz),1.0);\n  \n  // gl_FragColor ;\n  \n  vec4 spec = texture2D( tex1, vUv);\n  // gl_FragColor = spec;\n  gl_FragColor += vec4(spec.xyz,1.0);\n\n    \n  // gl_FragColor = texelA;\n  // gl_FragColor = texelB;\n  // gl_FragColor = texelC;\n\n  // gl_FragColor = texture2D( tex, vUv);\n\n  // gl_FragColor = gl_FragColor*gl_FragColor;\n  // gl_FragColor = vec4( (texel1 + texel1) + texel2  + texel3  );\n  // gl_FragColor = ((gl_FragColor - 0.5) * 3.0) + 0.5;\n  // gl_FragColor -= vec4(vec3(rand(vUv*(time))),1.0)*0.9;\n  // gl_FragColor = vec4( 1.0,0.0,0.0,1.0 );\n\n}']),o=a(["#define GLSLIFY 1\nvarying vec2 vUv;\nvarying vec3 vPos;\nvoid main() {\n  vUv = uv;\n  vPos = position;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"]);THREE.PostProcessing={uniforms:{tDiffuse:{value:null},tex1:{type:"t",value:null},tex2:{type:"t",value:null},mouseX:{value:1},mouseY:{value:1},time:{value:1},v:{value:1},opacity:{value:1}},vertexShader:o,fragmentShader:r}},{glslify:10}],3:[function(e,n,t){"use strict";function a(){function e(){n=window.innerWidth,t=window.innerHeight,o&&(o.setSize(n,t),o.setViewport(0,0,n,t),s.aspect=n/t,s.updateProjectionMatrix())}var n,t;n=window.innerWidth,t=window.innerHeight;var a=Math.min(1.5,window.devicePixelRatio),o=new THREE.WebGLRenderer({canvas:document.getElementById("canvas")});o.setClearColor(7829367,1),o.setSize(n,t),o.setPixelRatio(a);var i=new THREE.Scene,s=new THREE.PerspectiveCamera(25,n/t,.01,100);return s.position.set(-3,1,5),s.lookAt(new THREE.Vector3),console.log(s.position),new r(s),window.addEventListener("resize",e),{renderer:o,scene:i,camera:s}}var r=e("three-orbit-controls")(THREE);n.exports=a},{"three-orbit-controls":11}],4:[function(e,n,t){"use strict";THREE.EffectComposer=function(e,n){if(this.renderer=e,void 0===n){var t={minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBAFormat,stencilBuffer:!1},a=e.getDrawingBufferSize();n=new THREE.WebGLRenderTarget(a.width,a.height,t),n.texture.name="EffectComposer.rt1"}this.renderTarget1=n,this.renderTarget2=n.clone(),this.renderTarget2.texture.name="EffectComposer.rt2",this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2,this.passes=[],void 0===THREE.CopyShader&&console.error("THREE.EffectComposer relies on THREE.CopyShader"),void 0===THREE.ShaderPass&&console.error("THREE.EffectComposer relies on THREE.ShaderPass"),this.copyPass=new THREE.ShaderPass(THREE.CopyShader)},Object.assign(THREE.EffectComposer.prototype,{swapBuffers:function(){var e=this.readBuffer;this.readBuffer=this.writeBuffer,this.writeBuffer=e},addPass:function(e){this.passes.push(e);var n=this.renderer.getDrawingBufferSize();e.setSize(n.width,n.height)},insertPass:function(e,n){this.passes.splice(n,0,e)},render:function(e){var n,t,a=!1,r=this.passes.length;for(t=0;t<r;t++)if(n=this.passes[t],!1!==n.enabled){if(n.render(this.renderer,this.writeBuffer,this.readBuffer,e,a),n.needsSwap){if(a){var o=this.renderer.context;o.stencilFunc(o.NOTEQUAL,1,4294967295),this.copyPass.render(this.renderer,this.writeBuffer,this.readBuffer,e),o.stencilFunc(o.EQUAL,1,4294967295)}this.swapBuffers()}void 0!==THREE.MaskPass&&(n instanceof THREE.MaskPass?a=!0:n instanceof THREE.ClearMaskPass&&(a=!1))}},reset:function(e){if(void 0===e){var n=this.renderer.getDrawingBufferSize();e=this.renderTarget1.clone(),e.setSize(n.width,n.height)}this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.renderTarget1=e,this.renderTarget2=e.clone(),this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2},setSize:function(e,n){this.renderTarget1.setSize(e,n),this.renderTarget2.setSize(e,n);for(var t=0;t<this.passes.length;t++)this.passes[t].setSize(e,n)}}),THREE.Pass=function(){this.enabled=!0,this.needsSwap=!0,this.clear=!1,this.renderToScreen=!1},Object.assign(THREE.Pass.prototype,{setSize:function(e,n){},render:function(e,n,t,a,r){console.error("THREE.Pass: .render() must be implemented in derived pass.")}})},{}],5:[function(e,n,t){"use strict";THREE.RenderPass=function(e,n,t,a,r){THREE.Pass.call(this),this.scene=e,this.camera=n,this.overrideMaterial=t,this.clearColor=a,this.clearAlpha=void 0!==r?r:0,this.clear=!0,this.clearDepth=!1,this.needsSwap=!1},THREE.RenderPass.prototype=Object.assign(Object.create(THREE.Pass.prototype),{constructor:THREE.RenderPass,render:function(e,n,t,a,r){var o=e.autoClear;e.autoClear=!1,this.scene.overrideMaterial=this.overrideMaterial;var i,s;this.clearColor&&(i=e.getClearColor().getHex(),s=e.getClearAlpha(),e.setClearColor(this.clearColor,this.clearAlpha)),this.clearDepth&&e.clearDepth(),e.render(this.scene,this.camera,this.renderToScreen?null:t,this.clear),this.clearColor&&e.setClearColor(i,s),this.scene.overrideMaterial=null,e.autoClear=o}})},{}],6:[function(e,n,t){"use strict";THREE.SSAARenderPass=function(e,n,t,a){THREE.Pass.call(this),this.scene=e,this.camera=n,this.sampleLevel=4,this.unbiased=!0,this.clearColor=void 0!==t?t:0,this.clearAlpha=void 0!==a?a:0,void 0===THREE.CopyShader&&console.error("THREE.SSAARenderPass relies on THREE.CopyShader");var r=THREE.CopyShader;this.copyUniforms=THREE.UniformsUtils.clone(r.uniforms),this.copyMaterial=new THREE.ShaderMaterial({uniforms:this.copyUniforms,vertexShader:r.vertexShader,fragmentShader:r.fragmentShader,premultipliedAlpha:!0,transparent:!0,blending:THREE.AdditiveBlending,depthTest:!1,depthWrite:!1}),this.camera2=new THREE.OrthographicCamera(-1,1,1,-1,0,1),this.scene2=new THREE.Scene,this.quad2=new THREE.Mesh(new THREE.PlaneGeometry(2,2),this.copyMaterial),this.quad2.frustumCulled=!1,this.scene2.add(this.quad2)},THREE.SSAARenderPass.prototype=Object.assign(Object.create(THREE.Pass.prototype),{constructor:THREE.SSAARenderPass,dispose:function(){this.sampleRenderTarget&&(this.sampleRenderTarget.dispose(),this.sampleRenderTarget=null)},setSize:function(e,n){this.sampleRenderTarget&&this.sampleRenderTarget.setSize(e,n)},render:function(e,n,t,a,r){this.sampleRenderTarget||(this.sampleRenderTarget=new THREE.WebGLRenderTarget(t.width,t.height,{minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBAFormat}));var o=THREE.SSAARenderPass.JitterVectors[Math.max(0,Math.min(this.sampleLevel,5))],i=e.autoClear;e.autoClear=!1;var s=e.getClearColor().getHex(),c=e.getClearAlpha(),l=1/o.length;this.copyUniforms.tDiffuse.value=this.sampleRenderTarget.texture;for(var v=t.width,u=t.height,m=0;m<o.length;m++){var d=o[m];this.camera.setViewOffset&&this.camera.setViewOffset(v,u,.0625*d[0],.0625*d[1],v,u);var h=l;if(this.unbiased){h+=1/32*((m+.5)/o.length-.5)}this.copyUniforms.opacity.value=h,e.setClearColor(this.clearColor,this.clearAlpha),e.render(this.scene,this.camera,this.sampleRenderTarget,!0),0===m&&e.setClearColor(0,0),e.render(this.scene2,this.camera2,this.renderToScreen?null:n,0===m)}this.camera.clearViewOffset&&this.camera.clearViewOffset(),e.autoClear=i,e.setClearColor(s,c)}}),THREE.SSAARenderPass.JitterVectors=[[[0,0]],[[4,4],[-4,-4]],[[-2,-6],[6,-2],[-6,2],[2,6]],[[1,-3],[-1,3],[5,1],[-3,-5],[-5,5],[-7,-1],[3,7],[7,-7]],[[1,1],[-1,-3],[-3,2],[4,-1],[-5,-2],[2,5],[5,3],[3,-5],[-2,6],[0,-7],[-4,-6],[-6,4],[-8,0],[7,-4],[6,7],[-7,-8]],[[-4,-7],[-7,-5],[-3,-5],[-5,-4],[-1,-4],[-2,-2],[-6,-1],[-4,0],[-7,1],[-1,2],[-6,3],[-3,3],[-7,6],[-3,6],[-5,7],[-1,7],[5,-7],[1,-6],[6,-5],[4,-4],[2,-3],[7,-2],[1,-1],[4,-1],[2,1],[6,2],[0,4],[4,4],[2,5],[7,5],[5,6],[3,7]]]},{}],7:[function(e,n,t){"use strict";THREE.ShaderPass=function(e,n){THREE.Pass.call(this),this.textureID=void 0!==n?n:"tDiffuse",e instanceof THREE.ShaderMaterial?(this.uniforms=e.uniforms,this.material=e):e&&(this.uniforms=THREE.UniformsUtils.clone(e.uniforms),this.material=new THREE.ShaderMaterial({defines:e.defines||{},uniforms:this.uniforms,vertexShader:e.vertexShader,fragmentShader:e.fragmentShader})),this.camera=new THREE.OrthographicCamera(-1,1,1,-1,0,1),this.scene=new THREE.Scene,this.quad=new THREE.Mesh(new THREE.PlaneBufferGeometry(2,2),null),this.quad.frustumCulled=!1,this.scene.add(this.quad)},THREE.ShaderPass.prototype=Object.assign(Object.create(THREE.Pass.prototype),{constructor:THREE.ShaderPass,render:function(e,n,t,a,r){this.uniforms[this.textureID]&&(this.uniforms[this.textureID].value=t.texture),this.quad.material=this.material,this.renderToScreen?e.render(this.scene,this.camera):e.render(this.scene,this.camera,n,this.clear)}})},{}],8:[function(e,n,t){"use strict";THREE.CopyShader={uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform float opacity;","uniform sampler2D tDiffuse;","varying vec2 vUv;","void main() {","vec4 texel = texture2D( tDiffuse, vUv );","gl_FragColor = opacity * texel;","}"].join("\n")}},{}],9:[function(e,n,t){"use strict";function a(){var e=$(window).width(),n=$(window).height(),t=Math.min(1,window.devicePixelRatio);U.setSize(e*t,n*t),N.setSize(e*t,n*t),Y.setSize(e*t,n*t)}function r(){k+=.02,k>6.28&&(k-=6.28),P.time.value+=.03,P.lightDirection.value.x=-1.2*Math.sin(2*k),P.lightDirection.value.y=1,P.lightDirection.value.z=-1.2*Math.cos(2*k),R.position.x=P.lightDirection.value.x,R.position.y=P.lightDirection.value.y,R.position.z=P.lightDirection.value.z,requestAnimationFrame(r),m.render(u,v),N.render(),Y.render(),F.uniforms.tex1.value=j.texture,F.uniforms.tex2.value=G.texture,U.render()}var o=e("./lib/createThree");e("./lib/shaders/CopyShader"),e("./lib/postprocessing/EffectComposer"),e("./lib/postprocessing/ShaderPass"),e("./lib/postprocessing/SSAARenderPass"),e("./lib/postprocessing/RenderPass"),e("./lib/PostProcessing"),e("./lib/OBJLoader.js")
;var i,s,c,l=o(),v=l.camera,u=l.scene,m=l.renderer,d=e("glslify"),h=d(["#define GLSLIFY 1\n/**\n * Set the colour to a lovely pink.\n * Note that the color is a 4D Float\n * Vector, R,G,B and A and each part\n * runs from 0.0 to 1.0\n */\n\nuniform vec3 lightDirection;\nuniform vec3 eyeDirection;\nuniform float time;\n\nvarying vec3 vNormal;\nvarying vec3 vNormal2;\nvarying vec4 vPosition;\nvarying vec4 vPosition2;\nvarying vec4 vColor;\n\nvarying mat4 vInvMatrix;\n\nvec3 mix3vec(vec3 value){\n    return vec3(\n      mix(-1.0, 1.0, value.x),\n      mix(-1.0, 1.0, value.y),\n      mix(-1.0, 1.0, value.z)\n    );\n  }\n  \n  \nvoid main() {\n\n  vec4 ambientColor = vec4(0.2,0.2,0.2,1.0);\n\n  vec3  lightVec  = lightDirection - vPosition2.xyz;\n  vec3  invLight  = normalize(vInvMatrix * vec4(lightVec, 0.0)).xyz;\n  vec3  invEye    = normalize(vInvMatrix * vec4(eyeDirection, 0.0)).xyz;\n  vec3  halfLE    = normalize(invLight + invEye);\n  float diffuse   = clamp(dot(vNormal, invLight), 0.0, 1.0);\n  float specular  = pow(clamp(dot(vNormal, halfLE), 0.0, 1.0), 50.0);\n  vec4  destColor = vColor + vec4(vec3(diffuse), 1.0) + vec4(vec3(specular), 1.0) + ambientColor;\n\n  // diffuse\n  // gl_FragColor = vec4(vec3(diffuse-0.5) * 3.0, 1.0);\n  \n\n  // specular\n  \n  float specular2 = -1. * (specular-0.4);\n  vec4 specularOut = vec4(vec3(min(1.0,specular2*10.0)), 1.0);\n  gl_FragColor = specularOut;\n  \n  // depth\n\t// float depth = (vPosition.z / vPosition.w + 1.0) * 0.5;\n  // gl_FragColor = vec4(vec3(depth), 1.0);\n\n  // normal ( camera )\n  vec4 normalOut = vec4(vec3(vNormal2.zzz) * 1.6, 1.0);\n  // gl_FragColor = normalOut;\n  gl_FragColor = vec4(\n    normalOut.xyz * specularOut.xyz* vColor.xyz,\n    1.0\n  );\n\n  // gl_FragColor = vec4( normalOut.x * specularOut.x,  // R\n  //                       0.0,  // G\n  //                       0.0,  // B\n  //                       1.0); // A\n\n  // gl_FragColor = vec4(1.0,  // R\n  //                     1.0,  // G\n  //                     1.0,  // B\n  //                     1.0); // A\n\n}"]),f=d(["#define GLSLIFY 1\nfloat inverse(float m) {\n  return 1.0 / m;\n}\n\nmat2 inverse(mat2 m) {\n  return mat2(m[1][1],-m[0][1],\n             -m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n}\n\nmat3 inverse(mat3 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n  float b01 = a22 * a11 - a12 * a21;\n  float b11 = -a22 * a10 + a12 * a20;\n  float b21 = a21 * a10 - a11 * a20;\n\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nmat4 inverse(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\n\nuniform vec4 color;\nvarying vec3 vNormal;\nvarying vec3 vNormal2;\nvarying vec4 vPosition;\nvarying vec4 vPosition2;\nvarying vec4 vColor;\n\nvarying mat4 vInvMatrix;\n\nvoid main() {\n\n  vNormal     = normal;\n  vNormal2     = normalMatrix * normal;\n\n  vColor = color;\n  vInvMatrix = inverse(modelMatrix);\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);\n  vPosition   = gl_Position;\n  vPosition2  = modelMatrix * vec4(position,1.0);\n}"]),g=d(["#define GLSLIFY 1\n/**\n * Set the colour to a lovely pink.\n * Note that the color is a 4D Float\n * Vector, R,G,B and A and each part\n * runs from 0.0 to 1.0\n */\n\nuniform vec3 lightDirection;\nuniform vec3 eyeDirection;\nuniform float time;\n\nvarying vec3 vNormal;\nvarying vec3 vNormal2;\nvarying vec4 vPosition;\nvarying vec4 vPosition2;\nvarying vec4 vColor;\n\nvarying mat4 vInvMatrix;\n\nvec3 mix3vec(vec3 value){\n    return vec3(\n      mix(-1.0, 1.0, value.x),\n      mix(-1.0, 1.0, value.y),\n      mix(-1.0, 1.0, value.z)\n    );\n  }\n  \n  \nvoid main() {\n\n  vec4 ambientColor = vec4(0.2,0.2,0.2,1.0);\n\n  vec3  lightVec  = lightDirection - vPosition2.xyz;\n  vec3  invLight  = normalize(vInvMatrix * vec4(lightVec, 0.0)).xyz;\n  vec3  invEye    = normalize(vInvMatrix * vec4(eyeDirection, 0.0)).xyz;\n  vec3  halfLE    = normalize(invLight + invEye);\n  float diffuse   = clamp(dot(vNormal, invLight), 0.0, 1.0);\n  float specular  = pow(clamp(dot(vNormal, halfLE), 0.0, 1.0), 50.0);\n  vec4  destColor = vColor + vec4(vec3(diffuse), 1.0) + vec4(vec3(specular), 1.0) + ambientColor;\n\n  // diffuse\n  // gl_FragColor = vec4(vec3(diffuse-0.5) * 3.0, 1.0);\n  \n\n  // specular\n  \n  float specular2 = (specular-0.4);\n  vec4 specularOut = vec4(vec3(min(1.0,specular2*1.0)), 1.0);\n  gl_FragColor = specularOut;\n  \n  // depth\n\t// float depth = (vPosition.z / vPosition.w + 1.0) * 0.5;\n  // gl_FragColor = vec4(vec3(depth), 1.0);\n\n  // normal ( camera )\n  vec4 normalOut = vec4(vec3(vNormal2.zzz) * 1.6, 1.0);\n  // gl_FragColor = normalOut;\n  gl_FragColor = vec4(\n    normalOut.xyz * specularOut.xyz,\n    1.0\n  );\n\n  // gl_FragColor = vec4( normalOut.x * specularOut.x,  // R\n  //                       0.0,  // G\n  //                       0.0,  // B\n  //                       1.0); // A\n\n  // gl_FragColor = vec4(1.0,  // R\n  //                     1.0,  // G\n  //                     1.0,  // B\n  //                     1.0); // A\n\n}"]),p=d(["#define GLSLIFY 1\nfloat inverse(float m) {\n  return 1.0 / m;\n}\n\nmat2 inverse(mat2 m) {\n  return mat2(m[1][1],-m[0][1],\n             -m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n}\n\nmat3 inverse(mat3 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n  float b01 = a22 * a11 - a12 * a21;\n  float b11 = -a22 * a10 + a12 * a20;\n  float b21 = a21 * a10 - a11 * a20;\n\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nmat4 inverse(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\n\nuniform vec4 color;\nvarying vec3 vNormal;\nvarying vec3 vNormal2;\nvarying vec4 vPosition;\nvarying vec4 vPosition2;\nvarying vec4 vColor;\n\nvarying mat4 vInvMatrix;\n\nvoid main() {\n\n  vNormal     = normal;\n  vNormal2     = normalMatrix * normal;\n\n  vColor = color;\n  vInvMatrix = inverse(modelMatrix);\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);\n  vPosition   = gl_Position;\n  vPosition2  = modelMatrix * vec4(position,1.0);\n}"]),b=d(["#define GLSLIFY 1\n/**\n * Set the colour to a lovely pink.\n * Note that the color is a 4D Float\n * Vector, R,G,B and A and each part\n * runs from 0.0 to 1.0\n */\n\nuniform vec3 lightDirection;\nuniform vec3 eyeDirection;\nuniform float time;\n\nvarying vec3 vNormal;\nvarying vec3 vNormal2;\nvarying vec4 vPosition;\nvarying vec4 vPosition2;\nvarying vec4 vColor;\n\nvarying mat4 vInvMatrix;\n\nvec3 mix3vec(vec3 value){\n    return vec3(\n      mix(-1.0, 1.0, value.x),\n      mix(-1.0, 1.0, value.y),\n      mix(-1.0, 1.0, value.z)\n    );\n  }\n  \n  \nvoid main() {\n\n  vec4 ambientColor = vec4(0.7,0.7,0.7,1.0);\n\n  vec3  lightVec  = lightDirection - vPosition2.xyz;\n  vec3  invLight  = normalize(vInvMatrix * vec4(lightVec, 0.0)).xyz;\n  vec3  invEye    = normalize(vInvMatrix * vec4(eyeDirection, 0.0)).xyz;\n  vec3  halfLE    = normalize(invLight + invEye);\n  float diffuse   = clamp(dot(vNormal, invLight), 0.0, 1.0);\n  float specular  = pow(clamp(dot(vNormal, halfLE), 0.0, 1.0), 50.0);\n  vec4  destColor = vColor + vec4(vec3(diffuse), 1.0) + vec4(vec3(specular), 1.0) + ambientColor;\n\n  // diffuse\n  // gl_FragColor = vec4(vec3(diffuse-0.5) * 3.0, 1.0);\n  \n\n  // specular\n  \n  float specular2 = (specular-0.4);\n  vec4 specularOut = vec4(vec3(min(1.0,specular2*10.0)), 1.0);\n  gl_FragColor = specularOut;\n  \n  // depth\n\t// float depth = (vPosition.z / vPosition.w + 1.0) * 0.5;\n  // gl_FragColor = vec4(vec3(depth), 1.0);\n\n  // normal ( camera )\n  vec4 normalOut = vec4(vec3(vNormal2.zzz) * 1.6, 1.0);\n  // gl_FragColor = normalOut;\n  gl_FragColor = vec4(\n    vec3(diffuse) + ambientColor.xyz,\n    1.0\n  );\n\n  // gl_FragColor = vec4( normalOut.x * specularOut.x,  // R\n  //                       0.0,  // G\n  //                       0.0,  // B\n  //                       1.0); // A\n\n  // gl_FragColor = vec4(1.0,  // R\n  //                     1.0,  // G\n  //                     1.0,  // B\n  //                     1.0); // A\n\n}"]),x=d(["#define GLSLIFY 1\nfloat inverse(float m) {\n  return 1.0 / m;\n}\n\nmat2 inverse(mat2 m) {\n  return mat2(m[1][1],-m[0][1],\n             -m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n}\n\nmat3 inverse(mat3 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n  float b01 = a22 * a11 - a12 * a21;\n  float b11 = -a22 * a10 + a12 * a20;\n  float b21 = a21 * a10 - a11 * a20;\n\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nmat4 inverse(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\n\nuniform vec4 color;\nvarying vec3 vNormal;\nvarying vec3 vNormal2;\nvarying vec4 vPosition;\nvarying vec4 vPosition2;\nvarying vec4 vColor;\n\nvarying mat4 vInvMatrix;\n\nvoid main() {\n\n  vNormal     = normal;\n  vNormal2     = normalMatrix * normal;\n\n  vColor = color;\n  vInvMatrix = inverse(modelMatrix);\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);\n  vPosition   = gl_Position;\n  vPosition2  = modelMatrix * vec4(position,1.0);\n\n}"]);(new THREE.OBJLoader).load("stanford-dragon2.obj",function(e){e.traverse(function(e){e instanceof THREE.Mesh&&(e.material=w)}),u.add(e),i=e}),(new THREE.OBJLoader).load("stanford-dragon2.obj",function(e){e.traverse(function(e){e instanceof THREE.Mesh&&(e.material=O)}),L.add(e),s=e}),(new THREE.OBJLoader).load("stanford-dragon2.obj",function(e){e.traverse(function(e){e instanceof THREE.Mesh&&(e.material=V)}),I.add(e),c=e});var E=new THREE.SphereGeometry(.1,64,64),y=new THREE.MeshBasicMaterial({color:16777215}),R=new THREE.Mesh(E,y),T=new THREE.SphereGeometry(.4,64,64),P={lightDirection:{value:new THREE.Vector3(-1,1.4,-1.5)},eyeDirection:{value:v.position},color:{value:new THREE.Vector4(155/255,155/255,155/255,1)},time:{value:0}},w=new THREE.ShaderMaterial({uniforms:P,vertexShader:f,fragmentShader:h}),C=new THREE.Mesh(T,w);u.add(C),C.position.y=-.6;var _=new THREE.MeshBasicMaterial({color:0,side:THREE.BackSide}),z=new THREE.Mesh(T,_);z.scale.set(1.02,1.02,1.02),z.position.set(.02,-.02,.02);var S=new THREE.MeshDepthMaterial,H=new THREE.Mesh(T,S);H.position.x=2,H.position.z=2;var D=new THREE.WebGLRenderTarget(500,500),U=new THREE.EffectComposer(m,D,16711680,1),M=new THREE.SSAARenderPass(u,v);M.sampleLevel=2,U.addPass(M);var F=new THREE.ShaderPass(THREE.PostProcessing);F.renderToScreen=!0,U.addPass(F);var L=new THREE.Scene,O=new THREE.ShaderMaterial({uniforms:P,vertexShader:p,fragmentShader:g}),A=new THREE.Mesh(T,O);L.add(A),A.position.y=-.6;var j=new THREE.WebGLRenderTarget(500,500),N=new THREE.EffectComposer(m,j,16711680,1),M=new THREE.SSAARenderPass(L,v);M.sampleLevel=2,N.addPass(M);var I=new THREE.Scene,V=new THREE.ShaderMaterial({uniforms:P,vertexShader:x,fragmentShader:b}),B=new THREE.Mesh(T,V);I.add(B),B.position.y=-.6;var G=new THREE.WebGLRenderTarget(500,500),Y=new THREE.EffectComposer(m,G,16711680,1),M=new THREE.SSAARenderPass(I,v);M.sampleLevel=2,Y.addPass(M),window.addEventListener("resize",a),a();var k=.4;r()},{"./lib/OBJLoader.js":1,"./lib/PostProcessing":2,"./lib/createThree":3,"./lib/postprocessing/EffectComposer":4,"./lib/postprocessing/RenderPass":5,"./lib/postprocessing/SSAARenderPass":6,"./lib/postprocessing/ShaderPass":7,"./lib/shaders/CopyShader":8,glslify:10}],10:[function(e,n,t){n.exports=function(e){"string"==typeof e&&(e=[e]);for(var n=[].slice.call(arguments,1),t=[],a=0;a<e.length-1;a++)t.push(e[a],n[a]||"");return t.push(e[a]),t.join("")}},{}],11:[function(e,n,t){n.exports=function(e){function n(n,t){function a(){return 2*Math.PI/60/60*F.autoRotateSpeed}function r(){return Math.pow(.95,F.zoomSpeed)}function o(e){B.theta-=e}function i(e){B.phi-=e}function s(n){F.object instanceof e.PerspectiveCamera?G/=n:F.object instanceof e.OrthographicCamera?(F.object.zoom=Math.max(F.minZoom,Math.min(F.maxZoom,F.object.zoom*n)),F.object.updateProjectionMatrix(),k=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),F.enableZoom=!1)}function c(n){F.object instanceof e.PerspectiveCamera?G*=n:F.object instanceof e.OrthographicCamera?(F.object.zoom=Math.max(F.minZoom,Math.min(F.maxZoom,F.object.zoom/n)),F.object.updateProjectionMatrix(),k=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),F.enableZoom=!1)}function l(e){Z.set(e.clientX,e.clientY)}function v(e){Q.set(e.clientX,e.clientY)}function u(e){W.set(e.clientX,e.clientY)}function m(e){q.set(e.clientX,e.clientY),X.subVectors(q,Z);var n=F.domElement===document?F.domElement.body:F.domElement;o(2*Math.PI*X.x/n.clientWidth*F.rotateSpeed),i(2*Math.PI*X.y/n.clientHeight*F.rotateSpeed),Z.copy(q),F.update()}function d(e){$.set(e.clientX,e.clientY),ee.subVectors($,Q),ee.y>0?s(r()):ee.y<0&&c(r()),Q.copy($),F.update()}function h(e){J.set(e.clientX,e.clientY),K.subVectors(J,W),ae(K.x,K.y),W.copy(J),F.update()}function f(e){}function g(e){e.deltaY<0?c(r()):e.deltaY>0&&s(r()),F.update()}function p(e){switch(e.keyCode){case F.keys.UP:ae(0,F.keyPanSpeed),F.update();break;case F.keys.BOTTOM:ae(0,-F.keyPanSpeed),F.update();break;case F.keys.LEFT:ae(F.keyPanSpeed,0),F.update();break;case F.keys.RIGHT:ae(-F.keyPanSpeed,0),F.update()}}function b(e){Z.set(e.touches[0].pageX,e.touches[0].pageY)}function x(e){var n=e.touches[0].pageX-e.touches[1].pageX,t=e.touches[0].pageY-e.touches[1].pageY,a=Math.sqrt(n*n+t*t);Q.set(0,a)}function E(e){W.set(e.touches[0].pageX,e.touches[0].pageY)}function y(e){q.set(e.touches[0].pageX,e.touches[0].pageY),X.subVectors(q,Z);var n=F.domElement===document?F.domElement.body:F.domElement;o(2*Math.PI*X.x/n.clientWidth*F.rotateSpeed),i(2*Math.PI*X.y/n.clientHeight*F.rotateSpeed),Z.copy(q),F.update()}function R(e){var n=e.touches[0].pageX-e.touches[1].pageX,t=e.touches[0].pageY-e.touches[1].pageY,a=Math.sqrt(n*n+t*t);$.set(0,a),ee.subVectors($,Q),ee.y>0?c(r()):ee.y<0&&s(r()),Q.copy($),F.update()}function T(e){J.set(e.touches[0].pageX,e.touches[0].pageY),K.subVectors(J,W),ae(K.x,K.y),W.copy(J),F.update()}function P(e){}function w(e){if(!1!==F.enabled){if(e.preventDefault(),e.button===F.mouseButtons.ORBIT){if(!1===F.enableRotate)return;l(e),N=j.ROTATE}else if(e.button===F.mouseButtons.ZOOM){if(!1===F.enableZoom)return;v(e),N=j.DOLLY}else if(e.button===F.mouseButtons.PAN){if(!1===F.enablePan)return;u(e),N=j.PAN}N!==j.NONE&&(document.addEventListener("mousemove",C,!1),document.addEventListener("mouseup",_,!1),F.dispatchEvent(O))}}function C(e){if(!1!==F.enabled)if(e.preventDefault(),N===j.ROTATE){if(!1===F.enableRotate)return;m(e)}else if(N===j.DOLLY){if(!1===F.enableZoom)return;d(e)}else if(N===j.PAN){if(!1===F.enablePan)return;h(e)}}function _(e){!1!==F.enabled&&(f(e),document.removeEventListener("mousemove",C,!1),document.removeEventListener("mouseup",_,!1),F.dispatchEvent(A),N=j.NONE)}function z(e){!1===F.enabled||!1===F.enableZoom||N!==j.NONE&&N!==j.ROTATE||(e.preventDefault(),e.stopPropagation(),g(e),F.dispatchEvent(O),F.dispatchEvent(A))}function S(e){!1!==F.enabled&&!1!==F.enableKeys&&!1!==F.enablePan&&p(e)}function H(e){if(!1!==F.enabled){switch(e.touches.length){case 1:if(!1===F.enableRotate)return;b(e),N=j.TOUCH_ROTATE;break;case 2:if(!1===F.enableZoom)return;x(e),N=j.TOUCH_DOLLY;break;case 3:if(!1===F.enablePan)return;E(e),N=j.TOUCH_PAN;break;default:N=j.NONE}N!==j.NONE&&F.dispatchEvent(O)}}function D(e){if(!1!==F.enabled)switch(e.preventDefault(),e.stopPropagation(),e.touches.length){case 1:if(!1===F.enableRotate)return;if(N!==j.TOUCH_ROTATE)return;y(e);break;case 2:if(!1===F.enableZoom)return;if(N!==j.TOUCH_DOLLY)return;R(e);break;case 3:if(!1===F.enablePan)return;if(N!==j.TOUCH_PAN)return;T(e);break;default:N=j.NONE}}function U(e){!1!==F.enabled&&(P(e),F.dispatchEvent(A),N=j.NONE)}function M(e){e.preventDefault()}this.object=n,this.domElement=void 0!==t?t:document,this.enabled=!0,this.target=new e.Vector3,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.25,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.enableKeys=!0,this.keys={LEFT:37,UP:38,RIGHT:39,BOTTOM:40},this.mouseButtons={ORBIT:e.MOUSE.LEFT,ZOOM:e.MOUSE.MIDDLE,PAN:e.MOUSE.RIGHT},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this.getPolarAngle=function(){return V.phi},this.getAzimuthalAngle=function(){return V.theta},this.reset=function(){F.target.copy(F.target0),F.object.position.copy(F.position0),F.object.zoom=F.zoom0,F.object.updateProjectionMatrix(),F.dispatchEvent(L),F.update(),N=j.NONE},this.update=function(){var t=new e.Vector3,r=(new e.Quaternion).setFromUnitVectors(n.up,new e.Vector3(0,1,0)),i=r.clone().inverse(),s=new e.Vector3,c=new e.Quaternion;return function(){var e=F.object.position;return t.copy(e).sub(F.target),t.applyQuaternion(r),V.setFromVector3(t),F.autoRotate&&N===j.NONE&&o(a()),V.theta+=B.theta,V.phi+=B.phi,V.theta=Math.max(F.minAzimuthAngle,Math.min(F.maxAzimuthAngle,V.theta)),V.phi=Math.max(F.minPolarAngle,Math.min(F.maxPolarAngle,V.phi)),V.makeSafe(),V.radius*=G,V.radius=Math.max(F.minDistance,Math.min(F.maxDistance,V.radius)),F.target.add(Y),t.setFromSpherical(V),t.applyQuaternion(i),e.copy(F.target).add(t),F.object.lookAt(F.target),!0===F.enableDamping?(B.theta*=1-F.dampingFactor,B.phi*=1-F.dampingFactor):B.set(0,0,0),G=1,Y.set(0,0,0),!!(k||s.distanceToSquared(F.object.position)>I||8*(1-c.dot(F.object.quaternion))>I)&&(F.dispatchEvent(L),s.copy(F.object.position),c.copy(F.object.quaternion),k=!1,!0)}}(),this.dispose=function(){F.domElement.removeEventListener("contextmenu",M,!1),F.domElement.removeEventListener("mousedown",w,!1),F.domElement.removeEventListener("wheel",z,!1),F.domElement.removeEventListener("touchstart",H,!1),F.domElement.removeEventListener("touchend",U,!1),F.domElement.removeEventListener("touchmove",D,!1),document.removeEventListener("mousemove",C,!1),document.removeEventListener("mouseup",_,!1),window.removeEventListener("keydown",S,!1)};var F=this,L={type:"change"},O={type:"start"},A={type:"end"},j={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_DOLLY:4,TOUCH_PAN:5},N=j.NONE,I=1e-6,V=new e.Spherical,B=new e.Spherical,G=1,Y=new e.Vector3,k=!1,Z=new e.Vector2,q=new e.Vector2,X=new e.Vector2,W=new e.Vector2,J=new e.Vector2,K=new e.Vector2,Q=new e.Vector2,$=new e.Vector2,ee=new e.Vector2,ne=function(){var n=new e.Vector3;return function(e,t){n.setFromMatrixColumn(t,0),n.multiplyScalar(-e),Y.add(n)}}(),te=function(){var n=new e.Vector3;return function(e,t){n.setFromMatrixColumn(t,1),n.multiplyScalar(e),Y.add(n)}}(),ae=function(){var n=new e.Vector3;return function(t,a){var r=F.domElement===document?F.domElement.body:F.domElement;if(F.object instanceof e.PerspectiveCamera){var o=F.object.position;n.copy(o).sub(F.target);var i=n.length();i*=Math.tan(F.object.fov/2*Math.PI/180),ne(2*t*i/r.clientHeight,F.object.matrix),te(2*a*i/r.clientHeight,F.object.matrix)}else F.object instanceof e.OrthographicCamera?(ne(t*(F.object.right-F.object.left)/F.object.zoom/r.clientWidth,F.object.matrix),te(a*(F.object.top-F.object.bottom)/F.object.zoom/r.clientHeight,F.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),F.enablePan=!1)}}();F.domElement.addEventListener("contextmenu",M,!1),F.domElement.addEventListener("mousedown",w,!1),F.domElement.addEventListener("wheel",z,!1),F.domElement.addEventListener("touchstart",H,!1),F.domElement.addEventListener("touchend",U,!1),F.domElement.addEventListener("touchmove",D,!1),window.addEventListener("keydown",S,!1),this.update()}return n.prototype=Object.create(e.EventDispatcher.prototype),n.prototype.constructor=n,Object.defineProperties(n.prototype,{center:{get:function(){return console.warn("THREE.OrbitControls: .center has been renamed to .target"),this.target}},noZoom:{get:function(){return console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."),!this.enableZoom},set:function(e){console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."),this.enableZoom=!e}},noRotate:{get:function(){return console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."),!this.enableRotate},set:function(e){console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."),this.enableRotate=!e}},noPan:{get:function(){return console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead."),!this.enablePan},set:function(e){console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead."),this.enablePan=!e}},noKeys:{get:function(){return console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."),!this.enableKeys},set:function(e){console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."),this.enableKeys=!e}},staticMoving:{get:function(){return console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."),!this.enableDamping},set:function(e){console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."),this.enableDamping=!e}},dynamicDampingFactor:{get:function(){return console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."),this.dampingFactor},set:function(e){console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."),this.dampingFactor=e}}}),n}},{}]},{},[9]);
