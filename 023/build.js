!function e(n,t,o){function r(a,c){if(!t[a]){if(!n[a]){var s="function"==typeof require&&require;if(!c&&s)return s(a,!0);if(i)return i(a,!0);var v=new Error("Cannot find module '"+a+"'");throw v.code="MODULE_NOT_FOUND",v}var l=t[a]={exports:{}};n[a][0].call(l.exports,function(e){var t=n[a][1][e];return r(t||e)},l,l.exports,e,n,t,o)}return t[a].exports}for(var i="function"==typeof require&&require,a=0;a<o.length;a++)r(o[a]);return r}({1:[function(e,n,t){"use strict";function o(){function e(){n=window.innerWidth,t=window.innerHeight,i&&(i.setSize(n,t),i.setViewport(0,0,n,t),c.aspect=n/t,c.updateProjectionMatrix())}var n,t;n=window.innerWidth,t=window.innerHeight;var o=Math.min(1.5,window.devicePixelRatio),i=new THREE.WebGLRenderer({canvas:document.getElementById("canvas"),antialias:!0,alpha:!0});i.setClearColor(13421772,0),i.setSize(n,t),i.setPixelRatio(o);var a=new THREE.Scene,c=new THREE.PerspectiveCamera(55,n/t,.01,1e3);c.position.set(0,0,-1),c.lookAt(new THREE.Vector3);var s=new r(c);return window.addEventListener("resize",e),{renderer:i,scene:a,controls:s,camera:c}}var r=e("three-orbit-controls")(THREE);n.exports=o},{"three-orbit-controls":4}],2:[function(e,n,t){"use strict";function o(){w.uniforms.id.value=0,_+=.01,_<6.28&&(_-=6.28),E.time.value+=1/60,E.height.value=-1*i.height,E.max1.value=i.max1,E.min1.value=i.min1,w.uniforms.time.value+=1/60,P.rotation.z=10,P.rotation.y+=625e-6,requestAnimationFrame(o),u.render(l,v)}var r=function(){this.height=.03,this.max1=75,this.min1=21},i=new r;window.text=i;var a=new dat.GUI;a.add(i,"height",0,.08).step(.01),a.add(i,"max1",0,500).step(1),a.add(i,"min1",0,500).step(1);var c=e("./lib/createThree"),s=c(),v=s.camera,l=s.scene,u=s.renderer;s.controls;window.renderer=u,u.shadowMap.enabled=!0,u.shadowMap.type=THREE.PCFSoftShadowMap;var m=e("glslify"),p=m(['precision highp float;\n#define GLSLIFY 1\n\n//\n// GLSL textureless classic 2D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec2 fade(vec2 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec2 P)\n{\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod289(Pi); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute(permute(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n  vec4 gy = abs(gx) - 0.5 ;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\n/**\n * Set the colour to a lovely pink.\n * Note that the color is a 4D Float\n * Vector, R,G,B and A and each part\n * runs from 0.0 to 1.0\n */\n\nuniform sampler2D texture1;\n\nvarying vec2 vUv;\nuniform float time;\n\nuniform sampler2D tMatCap;\nuniform sampler2D tMatCap2;\nuniform sampler2D mtex1;\nuniform sampler2D mtex2;\nvarying vec3 vNormal;\nvarying vec3 vPostion;\nvarying mat4 vModelViewMatrix;\nvarying mat3 vNormalMatrix;\nvarying vec3 vViewPosition;\n\nvarying vec3 vWorldPosition;\nuniform vec3 lightPosition1;\nuniform vec3 lightPosition2;\nuniform float height;\nuniform float max1;\nuniform float min1;\n\nvarying vec2 vN2;\nvarying vec3 e;\nvarying vec3 n;\n\nfloat rand(vec2 co){\n    return sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453;\n}\n\nvec2 parallaxMap( in vec3 V ) {\n\n/*\n//    float initialHeight = texture2D( tMatCap2, vUv ).r;\n    float initialHeight = texture2D( mtex2, vUv ).r;\n\n    // No Offset Limitting: messy, floating output at grazing angles.\n    //"vec2 texCoordOffset = parallaxScale * V.xy / V.z * initialHeight;",\n\n    // Offset Limiting\n    vec2 texCoordOffset = c * V.xy * initialHeight;\n    return vUv - texCoordOffset;\n    */\n\n    // Determine number of layers from angle between V and N\n    float numLayers = mix( max1, min1, abs( dot( vec3( 0.0, 0.0, 1.0 ), V ) ) );\n\n    float layerHeight = 1.0 / numLayers;\n    float currentLayerHeight = 0.0;\n    // Shift of texture coordinates for each iteration\n    vec2 dtex = height * V.xy / V.z / numLayers;\n\n    vec2 currentTextureCoords = vUv;\n\n    float heightFromTexture = texture2D( tMatCap2, currentTextureCoords ).r;\n\n    // while ( heightFromTexture > currentLayerHeight )\n    // Infinite loops are not well supported. Do a "large" finite\n    // loop, but not too large, as it slows down some compilers.\n    for ( int i = 0; i < 30; i += 1 ) {\n      if ( heightFromTexture <= currentLayerHeight ) {\n        break;\n      }\n      currentLayerHeight += layerHeight;\n      // Shift texture coordinates along vector V\n      currentTextureCoords -= dtex;\n      heightFromTexture = texture2D( tMatCap2, currentTextureCoords ).r;\n    }\n\n    return currentTextureCoords;\n\n}\n\nvec2 perturbUv( vec3 surfPosition, vec3 surfNormal, vec3 viewPosition ) {\n\n    vec2 texDx = dFdx( vUv );\n    vec2 texDy = dFdy( vUv );\n\n    vec3 vSigmaX = dFdx( surfPosition );\n    vec3 vSigmaY = dFdy( surfPosition );\n    vec3 vR1 = cross( vSigmaY, surfNormal );\n    vec3 vR2 = cross( surfNormal, vSigmaX );\n    float fDet = dot( vSigmaX, vR1 );\n\n    vec2 vProjVscr = ( 1.0 / fDet ) * vec2( dot( vR1, viewPosition ), dot( vR2, viewPosition ) );\n    vec3 vProjVtex;\n    vProjVtex.xy = texDx * vProjVscr.x + texDy * vProjVscr.y;\n    vProjVtex.z = dot( surfNormal, viewPosition );\n\n    return parallaxMap( vProjVtex );\n}\n\nvoid main() {\n\n  vNormalMatrix;\n  vNormal;\n  vUv;\n\n  vec3 mNormal    = (texture2D(mtex2, vUv) * 2.0 - 1.0).rgb;\n\n//  float c = 0.35 + max(0.0, dot(vNormal, lightDirection)) * 0.4 * shadowMask.x;\n\n  vec4 p = vec4( vPostion, 1. );\n  vec3 e = normalize( vec3( vModelViewMatrix * p ) );\n  vec3 n = normalize( vNormal );\n\n//  float c = max(0.0, dot(n, lightDirection));\n  vec3 c = vec3(0.3);\n  c += max(0.0, dot(normalize(vNormal), normalize(lightPosition1))) * vec3(0.90,0.95,0.95) * 2.1;\n  c += max(0.0, dot(normalize(vNormal), normalize(lightPosition2))) * 1.7;\n\n//  c += max(0.0, dot(normalize(mNormal), normalize(lightPosition1))) * max(0.0, dot(normalize(vNormal), normalize(lightPosition1)));\n//  c += max(0.0, dot(normalize(mNormal), normalize(lightPosition2))) * max(0.0, dot(normalize(vNormal), normalize(lightPosition2)));\n\n//  c += max(0.0, dot(normalize(mNormal), normalize(lightPosition2)));\n\n  vec3 r = reflect( e, n );\n  float m = 2. * sqrt(\n    pow( r.x, 2. ) +\n    pow( r.y, 2. ) +\n    pow( r.z + 1., 2. )\n  );\n  vec2 vN = r.xy / m + .5;\n\n  vec3 base = texture2D( tMatCap, vN ).rgb;\n//  vec3 base = texture2D( tMatCap, vUv ).rgb;\n//  gl_FragColor = vec4( base , 1.0 );\n//  gl_FragColor = vec4( vNormal , 1.0 );\n//  gl_FragColor = vec4( c, 1.0 );\n\n   vec2 mapUv = perturbUv( -vViewPosition, normalize( vNormal ), normalize( vViewPosition ) );\n//  vec3 base2 = texture2D( tMatCap2, vUv ).rgb;\n//  vec3 base22 = texture2D( tMatCap2, vUv - base2.r * 0.05 ).rgb;\n//  vec3 base22 = texture2D( tMatCap2, mapUv ).rgb;\n  vec3 base22 = texture2D( tMatCap2, mapUv ).rgb;\n  vec3 base22r = (1.0-texture2D( tMatCap2, mapUv ).rgb);\n//  vec3 base222 = texture2D( tMatCap2, mapUv ).rgb;\n//  vec3 base223 = texture2D( mtex1, mapUv ).rgb;\n//  gl_FragColor = vec4( base2, base2.r<0.2?1.0:0.0 );\n\n//  gl_FragColor -= vec4( vec3(0.4,1.4,0.2) * base22, 0.0 );\n  gl_FragColor += vec4( vec3(22./255.,22./255.,22./255.) * base22, 1.0 );\n  gl_FragColor += vec4( vec3(232./255.,232./255.,232./255.) * base22r, 1.0 );\n  gl_FragColor = base22r.r < 0.5?gl_FragColor:vec4(vec3(232./255., 202./255., 59./255.)*smoothstep(0.0,0.5,base22r), 1.0 );\n//  gl_FragColor = base22r.r < 0.5?gl_FragColor:vec4(vec3(232./255., 202./255., 59./255.)*smoothstep(0.0,1.0,base22r), 1.0 );\n//  gl_FragColor = base22r.r < 0.5?gl_FragColor:vec4(vec3(232./255., 202./255., 59./255.)*smoothstep(0.0,1.0,base22r), 1.0 );\n\n//  gl_FragColor += vec4( vec3(32./255.,32./255.,32./255.) * base22*.5, 1.0 );\n\n//  gl_FragColor += vec4( vec3(232./255.,132./255.,232./255.)* base22r , 1.0 );\n//  gl_FragColor += vec4( vec3(1.0,1.0,1.0) * base223, 1.0 );\n//  gl_FragColor += vec4( vec3(0.1,0.3,0.3), 1.0 );\n//  gl_FragColor += vec4( vec3(1.0,1.0,1.0)*base22, 1.0 );\n//  gl_FragColor += vec4( base22, 1.0 );\n\n//  gl_FragColor *= vec4( vec3(sin(vUv.x*4000.0) + sin(vUv.y*4000.0)),1.0);\n\n    gl_FragColor *= vec4( c*base22r, 1.0 );\n\n//\n//  vec3 base3 = texture2D( mtex1, vUv ).rgb;\n//  gl_FragColor *= vec4( 1.0 - base3, 1.0 );\n\n//    gl_FragColor *= vec4( vNormal, 1.0 );\n\n//  vec3 base2 = texture2D( tMatCap2, vN ).rgb;\n//  gl_FragColor = vec4( base2, 1.0 );\n\n}']),d=m(['#define GLSLIFY 1\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_0(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_0(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_0(vec4 x) {\n     return mod289_0(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_0(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289_0(i);\n  vec4 p = permute_0( permute_0( permute_0(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt_0(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_1(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_1(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_1(vec4 x)\n{\n  return mod289_1(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_1(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289_1(Pi0);\n  Pi1 = mod289_1(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute_1(permute_1(ix) + iy);\n  vec4 ixy0 = permute_1(ixy + iz0);\n  vec4 ixy1 = permute_1(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt_1(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt_1(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\n#define PI 3.1415;\n\nuniform float time;\nvarying vec2 vUv;\nuniform sampler2D tMatCap2;\nuniform sampler2D mtex2;\n\nvarying vec3 vNormal;\nvarying vec3 vPostion;\nvarying vec3 vWorldPosition;\nvarying mat4 vModelViewMatrix;\nvarying mat3 vNormalMatrix;\nvarying vec3 vViewPosition;\n\n// chunk(shadowmap_pars_vertex);\n\nvec3 makeNose(vec3 pos, vec2 uv2){\n//  return  (pos);\n//    return  (pos) + (normal * texture2D( mtex2, uv2 ).r) * 0.02;\n    return  (pos) + (normal * texture2D( tMatCap2, uv2 ).r) * 0.02;\n//    return  (pos) + (normal * texture2D( tMatCap2, uv2 ).r) * 0.2 + (normal * texture2D( mtex2, uv2 + time*.1 ).r) * 0.07 ;\n//    return  (pos) + (normal * texture2D( tMatCap2, uv2 ).r) * 0.2 + (normal * texture2D( mtex2, uv2 + time*.1 ).r) * 0.07 ;\n//    return  (pos) + (normal) * 0.1 - cnoise3(pos*2.0)*0.3;\n//  return  (pos) - cnoise3((pos))*0.3;\n//  return (pos) + (cnoise3((pos)*3.0 + time*0.8)*0.1) * normal;\n//  return (pos) + (cnoise3((pos)*10.0 + time*0.8)*0.1) * normal;\n}\n\nvec3 getNeighbour(vec3 orig, float offsetT, float offsetP){\n\n  // xyz -> Spherical coordinates\n  float r = sqrt(orig.x*orig.x + orig.y*orig.y + orig.z*orig.z);\n  float theta = acos(orig.z/r);\n  float sgn = (orig.y>=0.?1.:-1.);\n  float phi = sgn * acos(orig.x/sqrt(orig.x*orig.x + orig.y*orig.y));\n\n  // add offset\n  theta += offsetT;\n  phi += offsetP;\n\n  // Spherical coordinates -> xyz\n  float x = r * sin(theta) * cos(phi);\n  float y = r * sin(theta) * sin(phi);\n  float z = r * cos(theta);\n\n  return vec3( x, y, z );\n\n}\n\nvoid main() {\n\n  vUv = uv*1.0;\n  vUv.x *= 2.0;\n\n  vec3 pos = makeNose(position+vec3(0.001), vUv);\n\n  float gridOffset\t= 0.001;\n  vec3 neighbour1\t= makeNose(\n   getNeighbour(position+vec3(0.001)/*for specfic point(0,0,0)*/, gridOffset, 0.        ),\n   vec2(vUv.x + 0.001,vUv.y)\n  );\n\n  vec3 neighbour2\t= makeNose(\n   getNeighbour(position+vec3(0.001)/*for specfic point(0,0,0)*/,0.        , gridOffset),\n   vec2(vUv.x,vUv.y + 0.001)\n  );\n\n  vec3 tangent\t= neighbour1 - pos;\n  vec3 bitangent= neighbour2 - pos;\n\n  vec3 norm\t= cross(normalize(tangent), normalize(bitangent));\n//  norm = normalize(norm);\n//  norm = normalMatrix * norm;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.);\n\n  vPostion = pos;\n\n  vec4 worldPosition = modelMatrix * vec4(pos, 1.0);\n  // chunk(shadowmap_vertex);\n\n  // store the world position as varying for lighting\n  vWorldPosition = worldPosition.xyz;\n\n//  vNormal = norm;\n  vNormal = normalize( normalMatrix * normal );\n  vModelViewMatrix = modelViewMatrix;\n  vNormalMatrix = normalMatrix;\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vViewPosition = -mvPosition.xyz;\n\n}']),x=m(['//#pragma glslify: cnoise3 = require(glsl-noise/classic/3d)\n//\n// GLSL textureless classic 2D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec2 fade_0(vec2 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec2 P)\n{\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod289(Pi); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute(permute(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n  vec4 gy = abs(gx) - 0.5 ;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade_0(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\n//#extension GL_OES_standard_derivatives : enable\n\n#define iterations 17\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.15\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.010\n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform sampler2D tDiffuse;\nuniform sampler2D tex;\nuniform sampler2D mtex1;\nuniform float time;\nuniform float id;\nvarying vec2 vUv;\n\nconst vec2 resolution = vec2(512,512);\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\nfloat checkRect(vec2 lt, vec2 dims, vec2 coord){\n\tvec2 rb = lt + dims;\n\tif ((coord.x>lt.x) && (coord.x < rb.x) && (coord.y>lt.y) && (coord.y < rb.y))\n\t\treturn 1.0;\n\telse\n\t\treturn 0.0;\n}\n\nvec4 draw_ball(vec2 ball_center, vec3 ball_color, float ball_rad){\n//\tvec2 position = ( vUv.xy / vec2(1.,1.) );\n//\tvec2 center = ball_center;\n//\tvec2 curpos = position - center;\n//\n//\tfloat length_ = dot(curpos, curpos);\n//\tfloat coly = 0.0;\n//\tfloat r2 = ball_rad * ball_rad;\n//\tcoly = r2 / length_;\n\n\tvec2 m = ball_center;\n  vec2 p = (vUv.xy) / vec2(1.0,1.0);\n\n  // division\n  float t = 1.1 - length(m - p);\n  t = pow(t, 100.0)*ball_rad*ball_rad;\n\n\treturn vec4(ball_color * t, 1.0);\n}\n\nvoid main( void ) {\n\n\tvec3 outputColor = vec3 (0.0, 0.0, 0.0);\n//\n  vec2 m = vec2(.5 * 2.0 - 1.0, -.5 * 2.0 + 1.0);\n  vec2 p = (vUv * 2.0 - 1.0) / min(.5, .5);\n  vec2 uv = vUv - 0.5;\n//  uv *= vec2(1.0,2.0);\n\n//  outputColor = texture2D(tex, vUv).rgb;\n\n//  vec2 m1 = vec2(sin(time)*.4, cos(time)*.4);\n//  vec2 p1 = (vUv.xy * 2.0 - 1.0) / 1.0;\n\n  // one minus length\n//  float t = 0.1 - length(m1 - p1);\n//  t = pow(t, 5.0);\n\n//  outputColor += t;\n\n//\tt += abs( 1.0 / (sin( uv.x + sin(uv.y+time)* 0.0 ) * 40.0) );\n\n//\toutputColor += abs( 1.0 / (sin( (uv.x + sin(uv.y*20.0) * 0.01)) * 200.0) );\n//\toutputColor -= vec3(0.1,0.1,0.1);\n//\toutputColor += sin(cnoise2(uv*6.+time)*5.0) * 0.333\n//\t               + (1.0+sin(cnoise2(uv*3.+time) *5.0)) * 0.333\n//\t               + (1.0+sin(cnoise2(uv*4.+time) *5.0)) * 0.333;\n\n//\toutputColor += cnoise2(uv*3.) * 1.0;\n//\toutputColor += cnoise2(uv*4.) * 2.01;\n//\toutputColor += cnoise2(uv*6.) * 3.02;\n\n//\toutputColor -= cnoise2(uv*23.) * 1.01;\n//\toutputColor += cnoise2(uv*200.) * 1.02;\n//\toutputColor += cnoise2(uv*400.) * 1.02;\n//  outputColor += cnoise2(uv*200.) * 10.02;\n//\toutputColor += vec3((cnoise2(uv*40.)*10.0))  ;\n//\toutputColor -= cnoise2(uv*3.) * 100.01;\n//\toutputColor += cnoise2(uv*200.) * 10.02;\n//\toutputColor += cnoise2(uv*200.) * 10.02;\n//\toutputColor += cnoise2(uv*200.) * 10.02;\n//\toutputColor += (cnoise2(uv*300.)*.333 + cnoise2(uv*20.)*.333 + cnoise2(uv*4.)*.333 );\n//\toutputColor -= cnoise2(uv*7.) * 20.1;\n\n//  for( float i = 0.; i < 30.; i++ ){\n//    outputColor += (1.0-draw_ball(vec2(0.5 + i*0.1, 0.5), vec3(1.0, 1.0, 1.0), 0.05)).rgb;\n//  }\n\n//  for( float i = 0.; i < 5.; i++ ){\n//    outputColor += cnoise2(uv*(3. + i * 5.)) * .4;\n//    outputColor += (1.0-draw_ball(vec2(.5,.5), vec3(1.0, 1.0, 1.0), 0.1)*.5).rgb;\n//    outputColor += (1.0-draw_ball(vec2(.6,.5), vec3(1.0, 1.0, 1.0), 0.02)*1.0).rgb;\n//  }\n//    outputColor += cnoise2(uv*5.)*.5 + cnoise2(uv*5.)*.5;\n//     outputColor += cnoise2(uv*3.) * 4.5;\n//    outputColor += abs(cnoise2(uv*5.) * 10.0);\n\n//    outputColor += tan(cnoise2(vec2(uv.x,uv.y*2.0)*2.) * (1.0+cnoise2(uv)*60.0) )*.5;\n//    outputColor += (sin(cnoise2(vec2(uv.x,uv.y*2.0)*3.)*4.0) * 2.0 - 1.0) * .3;\n//    outputColor += (cos(cnoise2(vec2(uv.x,uv.y*2.0)*5.)*4.0) * 2.0 - 1.0) * .3;\n//    outputColor += (cos(cnoise2(vec2(uv.x,uv.y*2.0)*20.)*4.0) * 2.0 - 1.0) * .3;\n//    outputColor += cos(cnoise2(vec2(uv.x,uv.y*2.0)*10.)*10.0) * 2.0 - 1.0*.204;\n//    outputColor += cos(cnoise2(vec2(uv.x,uv.y*2.0)*3.)*10.0) * 2.0 - 1.0*.202;\n//    outputColor += cnoise2(vec2(uv.x,uv.y*2.0)*3.)*10.0*.203;\n//    outputColor += min(cnoise2(vec2(uv.x,uv.y*2.0)*3.0)*5.0,1.0);\n//    outputColor += sin(cnoise2(vec2(uv.x,uv.y*2.0)*7.0)*30. - cnoise2(vec2(uv.x,uv.y*1.0)*2.0)*100.)*.3;\n\n//for( float i = 0.; i < 5.; i++ ){\n//    outputColor += sin(\n//        cnoise2(\n//          vec2(uv.x,uv.y*2.0) * 9.// * vec2(uv.x,uv.y*2.)*1.0\n//        )*(20.0 - i * 4.)\n//      ) * 0.2;\n//}\n\n//      outputColor += sin(\n//              cnoise2(\n//                vec2(uv.x,uv.y*1.2) * 9.// * vec2(uv.x,uv.y*2.)*1.0\n//              )*2.0\n//            ) * 0.501;\n\n    outputColor += max(sin(cnoise(vec2(uv.x, uv.y*2.)*4.)*2.0)*.4,0.0);\n//    outputColor += max(cnoise2(vec2(uv.x, uv.y*2.)*4.0)*0.7,0.0);\n    outputColor += max(sin(cnoise(vec2(uv.x*1.1, uv.y*3.0)*4.)*120.0)*.1,0.0);\n\n//    outputColor *= max(cos(cnoise2(vec2(uv.x, uv.y*2.)*4.)*7.0)*.4,1.0);\n\n//    outputColor += random(uv)*.2;\n\n//    outputColor += random(uv*2.0)>0.1?1.0:0.0;\n\n//    vec3 base3 = texture2D( mtex1, uv ).rgb;\n//    outputColor *= base3.rrr;\n\n//\toutputColor -= cnoise2(uv*3.)*.7;\n\n//\toutputColor /= 10.;\n\n//  outputColor -= vec3(0.001,0.001,0.001);\n//  outputColor += sin(cnoise2(uv*6.+time)*5.0)*0.01;\n\n//\toutputColor += abs( 1.0 / (sin( (uv.x + sin(uv.y*10.0) * 0.01)) * 200.0) );// * sin(uv.y*20.0+ time);\n\n//\tuv += 0.35;\n//  outputColor += abs( 1.0 / (sin( uv.x+ sin(uv.y*40.0+time*10.0) * 0.01 ) * 200.0)) * .8;\n//\n//\n//\tuv -= 0.35;\n//  outputColor += vec3(abs( 3.0 * sin(time)*2.0 / (sin( uv.x) * 200.0) ),0.0,0.0);\n//\n//  uv -= 0.45;\n//  outputColor += abs( 3.0 / (sin( uv.x + (sin(time)+1.0)/2.0) * 200.0) ) * .8;\n//\n////  uv += 0.8;\n////  t += abs( 1.0 / (sin( (uv.x )) * 200.0) );//* sin(uv.y*30.0+ time);\n//\n////\tt *= abs( 1.0 / (sin( uv.x + sin(uv.y+time)* 0.0 ) * 40.0) );\n//\n//\n//\tvec2 posf = fract(vUv);\n//\n//  for(float i = 0.0; i < 20.0; i++){\n//\t  outputColor += vec3(checkRect(vec2(0.3,1.0 * i/20.0),vec2(.01,0.02),posf)) * .8;\n//  }\n//\n//  for(float i = 0.0; i < 3.0; i++){\n//  \t outputColor += vec3(checkRect(vec2(0.05,1.0 * i/3.0),vec2(.01,0.1),posf)) * .8;\n//  }\n//\n//  for(float i = 0.0; i < 14.0; i++){\n//\t  outputColor += vec3(checkRect(vec2(0.7,1.0 * i/14.0),vec2(.01+(i*0.003+sin(time)*0.1),0.02),posf)) * .8;\n//  }\n//\n//  for(float i = 0.0; i < 8.0; i++){\n//  \t outputColor += vec3(checkRect(vec2(0.85,1.0 * i/8.0),vec2(.01, 0.1),posf)) * .8;\n//  }\n//\n\n//\toutputColor += vec3(checkRect(\n//\t  vec2(0.3,0.0), // x,  y start points, bottom=0 top=1, left=0 right=1\n//\t  vec2(.01,0.7), // width, height\n//\tposf));\n\n//\toutputColor += vec3(checkRect(vec2(0.3,0.2),vec2(.01,1.),posf));\n\n  \tvec3 dir=vec3(vUv*zoom,1.);\n  \tfloat rtime=time*speed+.25;\n  \tvec3 from=vec3(1.,.5,0.5);\n\n  \t//volumetric rendering\n  \tfloat s=0.1,fade=1.;\n  \tvec3 v=vec3(0.);\n  \tfor (int r=0; r<volsteps; r++) {\n  \t\tvec3 p=from+s*dir*.5;\n  \t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n  \t\tfloat pa,a=pa=0.;\n  \t\tfor (int i=0; i<iterations; i++) {\n  \t\t\tp=abs(p)/dot(p,p)-formuparam; // the magic formula\n  \t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n  \t\t\tpa=length(p);\n  \t\t}\n  \t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n  \t\ta*=a*a; // add contrast\n  \t\t//if (r>6) fade*=1.-dm; // dark matter, don\'t render near\n  \t\t//v+=vec3(dm,dm*.5,0.);\n  \t\tv+=fade;\n  \t\tv+=vec3(s*s,s*s,s*s )*a*brightness*fade; // coloring based on distance\n  \t\tfade=0.1; // distance fading\n  \t\ts+=stepsize;\n  \t}\n  \tv=mix(vec3(length(v)),v,1.0); //color adjust\n//  \tgl_FragColor = vec4(v*.01,1.);\n    outputColor += v *.01;\n\n\tgl_FragColor = vec4(vec3(outputColor),1.0);//vec3(random(position)), 1.0);\n\n}']),g=m(["#define GLSLIFY 1\nvarying vec2 vUv;\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"]);THREE.Texture1={uniforms:{tDiffuse:{value:null},tDiffusePrev:{value:null},mouseX:{value:1},mouseY:{value:1},time:{value:1},opacity:{value:1},tex:{type:"t",value:null},id:{value:1},mtex1:{type:"t",value:null}},vertexShader:g,fragmentShader:x};var f=new THREE.SpotLight(16777215);f.position.set(-5,-5,-4),f.target.position.set(0,0,0);var y=(new THREE.SpotLightHelper(f),new THREE.SpotLight(16777215));y.position.set(5,5,5),y.target.position.set(0,0,0);var h=(new THREE.SpotLightHelper(y),new THREE.WebGLRenderTarget(1024,1024));h.texture.wrapS=THREE.MirroredRepeatWrapping,h.texture.wrapT=THREE.MirroredRepeatWrapping;var b=new THREE.EffectComposer(u,h),w=new THREE.ShaderPass(THREE.Texture1);b.addPass(w),w.uniforms.mtex1.value=THREE.ImageUtils.loadTexture("img/cobblestone_disp.jpg"),w.uniforms.mtex1.value.wrapS=w.uniforms.mtex1.value.wrapT=THREE.RepeatWrapping;var E={time:{type:"f",value:0},tMatCap:{type:"t",value:THREE.ImageUtils.loadTexture("img/rubber_black.png")},tMatCap2:{type:"t",value:h},mtex1:{type:"t",value:THREE.ImageUtils.loadTexture("img/cobblestone_disp.jpg")},mtex2:{type:"t",value:THREE.ImageUtils.loadTexture("img/cobblestone_disp.jpg")},height:{type:"f",value:0},max1:{type:"f",value:0},min1:{type:"f",value:0},lightPosition1:{type:"v3",value:f.position},lightPosition2:{type:"v3",value:y.position}};E.mtex1.value.wrapS=E.mtex1.value.wrapT=THREE.RepeatWrapping,E.mtex2.value.wrapS=E.mtex2.value.wrapT=THREE.RepeatWrapping;var C=new THREE.ShaderMaterial({uniforms:E,vertexShader:d,fragmentShader:p,transparent:!0,side:THREE.DoubleSide});C.extensions.derivatives=!0,C.extensions.drawBuffers=!0;var P=new THREE.Mesh(new THREE.SphereGeometry(.4,128,128),C);l.add(P);var z=new THREE.MeshBasicMaterial({map:h.texture});new THREE.Mesh(new THREE.PlaneGeometry(1,1),z).material.side=THREE.DoubleSide,b.render(),o();var _=0;console.log("asasas")},{"./lib/createThree":1,glslify:3}],3:[function(e,n,t){n.exports=function(e){"string"==typeof e&&(e=[e]);for(var n=[].slice.call(arguments,1),t=[],o=0;o<e.length-1;o++)t.push(e[o],n[o]||"");return t.push(e[o]),t.join("")}},{}],4:[function(e,n,t){n.exports=function(e){function n(n,t){function o(){return 2*Math.PI/60/60*O.autoRotateSpeed}function r(){return Math.pow(.95,O.zoomSpeed)}function i(e){I.theta-=e}function a(e){I.phi-=e}function c(n){O.object instanceof e.PerspectiveCamera?Y/=n:O.object instanceof e.OrthographicCamera?(O.object.zoom=Math.max(O.minZoom,Math.min(O.maxZoom,O.object.zoom*n)),O.object.updateProjectionMatrix(),q=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),O.enableZoom=!1)}function s(n){O.object instanceof e.PerspectiveCamera?Y*=n:O.object instanceof e.OrthographicCamera?(O.object.zoom=Math.max(O.minZoom,Math.min(O.maxZoom,O.object.zoom/n)),O.object.updateProjectionMatrix(),q=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),O.enableZoom=!1)}function v(e){Z.set(e.clientX,e.clientY)}function l(e){J.set(e.clientX,e.clientY)}function u(e){B.set(e.clientX,e.clientY)}function m(e){W.set(e.clientX,e.clientY),X.subVectors(W,Z);var n=O.domElement===document?O.domElement.body:O.domElement;i(2*Math.PI*X.x/n.clientWidth*O.rotateSpeed),
a(2*Math.PI*X.y/n.clientHeight*O.rotateSpeed),Z.copy(W),O.update()}function p(e){$.set(e.clientX,e.clientY),ee.subVectors($,J),ee.y>0?c(r()):ee.y<0&&s(r()),J.copy($),O.update()}function d(e){K.set(e.clientX,e.clientY),Q.subVectors(K,B),oe(Q.x,Q.y),B.copy(K),O.update()}function x(e){}function g(e){e.deltaY<0?s(r()):e.deltaY>0&&c(r()),O.update()}function f(e){switch(e.keyCode){case O.keys.UP:oe(0,O.keyPanSpeed),O.update();break;case O.keys.BOTTOM:oe(0,-O.keyPanSpeed),O.update();break;case O.keys.LEFT:oe(O.keyPanSpeed,0),O.update();break;case O.keys.RIGHT:oe(-O.keyPanSpeed,0),O.update()}}function y(e){Z.set(e.touches[0].pageX,e.touches[0].pageY)}function h(e){var n=e.touches[0].pageX-e.touches[1].pageX,t=e.touches[0].pageY-e.touches[1].pageY,o=Math.sqrt(n*n+t*t);J.set(0,o)}function b(e){B.set(e.touches[0].pageX,e.touches[0].pageY)}function w(e){W.set(e.touches[0].pageX,e.touches[0].pageY),X.subVectors(W,Z);var n=O.domElement===document?O.domElement.body:O.domElement;i(2*Math.PI*X.x/n.clientWidth*O.rotateSpeed),a(2*Math.PI*X.y/n.clientHeight*O.rotateSpeed),Z.copy(W),O.update()}function E(e){var n=e.touches[0].pageX-e.touches[1].pageX,t=e.touches[0].pageY-e.touches[1].pageY,o=Math.sqrt(n*n+t*t);$.set(0,o),ee.subVectors($,J),ee.y>0?s(r()):ee.y<0&&c(r()),J.copy($),O.update()}function C(e){K.set(e.touches[0].pageX,e.touches[0].pageY),Q.subVectors(K,B),oe(Q.x,Q.y),B.copy(K),O.update()}function P(e){}function z(e){if(!1!==O.enabled){if(e.preventDefault(),e.button===O.mouseButtons.ORBIT){if(!1===O.enableRotate)return;v(e),V=F.ROTATE}else if(e.button===O.mouseButtons.ZOOM){if(!1===O.enableZoom)return;l(e),V=F.DOLLY}else if(e.button===O.mouseButtons.PAN){if(!1===O.enablePan)return;u(e),V=F.PAN}V!==F.NONE&&(document.addEventListener("mousemove",_,!1),document.addEventListener("mouseup",T,!1),O.dispatchEvent(U))}}function _(e){if(!1!==O.enabled)if(e.preventDefault(),V===F.ROTATE){if(!1===O.enableRotate)return;m(e)}else if(V===F.DOLLY){if(!1===O.enableZoom)return;p(e)}else if(V===F.PAN){if(!1===O.enablePan)return;d(e)}}function T(e){!1!==O.enabled&&(x(e),document.removeEventListener("mousemove",_,!1),document.removeEventListener("mouseup",T,!1),O.dispatchEvent(j),V=F.NONE)}function M(e){!1===O.enabled||!1===O.enableZoom||V!==F.NONE&&V!==F.ROTATE||(e.preventDefault(),e.stopPropagation(),g(e),O.dispatchEvent(U),O.dispatchEvent(j))}function R(e){!1!==O.enabled&&!1!==O.enableKeys&&!1!==O.enablePan&&f(e)}function D(e){if(!1!==O.enabled){switch(e.touches.length){case 1:if(!1===O.enableRotate)return;y(e),V=F.TOUCH_ROTATE;break;case 2:if(!1===O.enableZoom)return;h(e),V=F.TOUCH_DOLLY;break;case 3:if(!1===O.enablePan)return;b(e),V=F.TOUCH_PAN;break;default:V=F.NONE}V!==F.NONE&&O.dispatchEvent(U)}}function S(e){if(!1!==O.enabled)switch(e.preventDefault(),e.stopPropagation(),e.touches.length){case 1:if(!1===O.enableRotate)return;if(V!==F.TOUCH_ROTATE)return;w(e);break;case 2:if(!1===O.enableZoom)return;if(V!==F.TOUCH_DOLLY)return;E(e);break;case 3:if(!1===O.enablePan)return;if(V!==F.TOUCH_PAN)return;C(e);break;default:V=F.NONE}}function N(e){!1!==O.enabled&&(P(e),O.dispatchEvent(j),V=F.NONE)}function L(e){e.preventDefault()}this.object=n,this.domElement=void 0!==t?t:document,this.enabled=!0,this.target=new e.Vector3,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.25,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.enableKeys=!0,this.keys={LEFT:37,UP:38,RIGHT:39,BOTTOM:40},this.mouseButtons={ORBIT:e.MOUSE.LEFT,ZOOM:e.MOUSE.MIDDLE,PAN:e.MOUSE.RIGHT},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this.getPolarAngle=function(){return k.phi},this.getAzimuthalAngle=function(){return k.theta},this.reset=function(){O.target.copy(O.target0),O.object.position.copy(O.position0),O.object.zoom=O.zoom0,O.object.updateProjectionMatrix(),O.dispatchEvent(H),O.update(),V=F.NONE},this.update=function(){var t=new e.Vector3,r=(new e.Quaternion).setFromUnitVectors(n.up,new e.Vector3(0,1,0)),a=r.clone().inverse(),c=new e.Vector3,s=new e.Quaternion;return function(){var e=O.object.position;return t.copy(e).sub(O.target),t.applyQuaternion(r),k.setFromVector3(t),O.autoRotate&&V===F.NONE&&i(o()),k.theta+=I.theta,k.phi+=I.phi,k.theta=Math.max(O.minAzimuthAngle,Math.min(O.maxAzimuthAngle,k.theta)),k.phi=Math.max(O.minPolarAngle,Math.min(O.maxPolarAngle,k.phi)),k.makeSafe(),k.radius*=Y,k.radius=Math.max(O.minDistance,Math.min(O.maxDistance,k.radius)),O.target.add(G),t.setFromSpherical(k),t.applyQuaternion(a),e.copy(O.target).add(t),O.object.lookAt(O.target),!0===O.enableDamping?(I.theta*=1-O.dampingFactor,I.phi*=1-O.dampingFactor):I.set(0,0,0),Y=1,G.set(0,0,0),!!(q||c.distanceToSquared(O.object.position)>A||8*(1-s.dot(O.object.quaternion))>A)&&(O.dispatchEvent(H),c.copy(O.object.position),s.copy(O.object.quaternion),q=!1,!0)}}(),this.dispose=function(){O.domElement.removeEventListener("contextmenu",L,!1),O.domElement.removeEventListener("mousedown",z,!1),O.domElement.removeEventListener("wheel",M,!1),O.domElement.removeEventListener("touchstart",D,!1),O.domElement.removeEventListener("touchend",N,!1),O.domElement.removeEventListener("touchmove",S,!1),document.removeEventListener("mousemove",_,!1),document.removeEventListener("mouseup",T,!1),window.removeEventListener("keydown",R,!1)};var O=this,H={type:"change"},U={type:"start"},j={type:"end"},F={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_DOLLY:4,TOUCH_PAN:5},V=F.NONE,A=1e-6,k=new e.Spherical,I=new e.Spherical,Y=1,G=new e.Vector3,q=!1,Z=new e.Vector2,W=new e.Vector2,X=new e.Vector2,B=new e.Vector2,K=new e.Vector2,Q=new e.Vector2,J=new e.Vector2,$=new e.Vector2,ee=new e.Vector2,ne=function(){var n=new e.Vector3;return function(e,t){n.setFromMatrixColumn(t,0),n.multiplyScalar(-e),G.add(n)}}(),te=function(){var n=new e.Vector3;return function(e,t){n.setFromMatrixColumn(t,1),n.multiplyScalar(e),G.add(n)}}(),oe=function(){var n=new e.Vector3;return function(t,o){var r=O.domElement===document?O.domElement.body:O.domElement;if(O.object instanceof e.PerspectiveCamera){var i=O.object.position;n.copy(i).sub(O.target);var a=n.length();a*=Math.tan(O.object.fov/2*Math.PI/180),ne(2*t*a/r.clientHeight,O.object.matrix),te(2*o*a/r.clientHeight,O.object.matrix)}else O.object instanceof e.OrthographicCamera?(ne(t*(O.object.right-O.object.left)/O.object.zoom/r.clientWidth,O.object.matrix),te(o*(O.object.top-O.object.bottom)/O.object.zoom/r.clientHeight,O.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),O.enablePan=!1)}}();O.domElement.addEventListener("contextmenu",L,!1),O.domElement.addEventListener("mousedown",z,!1),O.domElement.addEventListener("wheel",M,!1),O.domElement.addEventListener("touchstart",D,!1),O.domElement.addEventListener("touchend",N,!1),O.domElement.addEventListener("touchmove",S,!1),window.addEventListener("keydown",R,!1),this.update()}return n.prototype=Object.create(e.EventDispatcher.prototype),n.prototype.constructor=n,Object.defineProperties(n.prototype,{center:{get:function(){return console.warn("THREE.OrbitControls: .center has been renamed to .target"),this.target}},noZoom:{get:function(){return console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."),!this.enableZoom},set:function(e){console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."),this.enableZoom=!e}},noRotate:{get:function(){return console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."),!this.enableRotate},set:function(e){console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."),this.enableRotate=!e}},noPan:{get:function(){return console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead."),!this.enablePan},set:function(e){console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead."),this.enablePan=!e}},noKeys:{get:function(){return console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."),!this.enableKeys},set:function(e){console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."),this.enableKeys=!e}},staticMoving:{get:function(){return console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."),!this.enableDamping},set:function(e){console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."),this.enableDamping=!e}},dynamicDampingFactor:{get:function(){return console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."),this.dampingFactor},set:function(e){console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."),this.dampingFactor=e}}}),n}},{}]},{},[2]);
